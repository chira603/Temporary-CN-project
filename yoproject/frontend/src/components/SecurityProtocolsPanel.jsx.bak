import React, { useState, useEffect, useRef } from 'react';
import * as d3 from 'd3';
import '../styles/SecurityProtocolsPanel.css';

function SecurityProtocolsPanel({ onClose }) {
  const [selectedProtocol, setSelectedProtocol] = useState(null);
  const [showBrief, setShowBrief] = useState(false);
  const [simulationStep, setSimulationStep] = useState(0);
  const [selectedNode, setSelectedNode] = useState(null);
  const [showPacketDetails, setShowPacketDetails] = useState(false);
  const [packetDetails, setPacketDetails] = useState(null);
  const svgRef = useRef(null);

  const protocols = [
    {
      id: 'dot',
      name: 'DNS over TLS (DoT)',
      icon: 'ðŸ”’',
      port: '853',
      description: 'Encrypts DNS queries using TLS (Transport Layer Security) on dedicated port 853, preventing eavesdropping and tampering',
      benefits: 'Privacy protection, prevents DNS hijacking, ISP cannot see queries',
      standard: 'RFC 7858 (2016)',
      color: '#10b981',
      adoption: 'Supported by Android 9+, iOS 14+, major DNS providers'
    },
    {
      id: 'doh',
      name: 'DNS over HTTPS (DoH)',
      icon: 'ðŸ”',
      port: '443',
      description: 'Encapsulates DNS queries in HTTPS traffic, making them indistinguishable from regular web browsing',
      benefits: 'Maximum privacy, bypasses DNS filtering, works on all networks',
      standard: 'RFC 8484 (2018)',
      color: '#3b82f6',
      adoption: 'Firefox, Chrome, Edge, Brave - enabled by default'
    },
    {
      id: 'dnssec',
      name: 'DNSSEC (DNS Security Extensions)',
      icon: 'âœ…',
      port: '53',
      description: 'Cryptographically signs DNS records to ensure authenticity and integrity, preventing DNS spoofing',
      benefits: 'Validates DNS responses, prevents cache poisoning, ensures data integrity',
      standard: 'RFC 4033-4035 (2005)',
      color: '#8b5cf6',
      adoption: '~30% of domains, major TLDs (.com, .org) fully supported'
    }
  ];

  useEffect(() => {
    if (selectedProtocol && !showBrief && svgRef.current) {
      drawSecurityVisualization();
    }
  }, [selectedProtocol, simulationStep, showBrief]);

  const getProtocolSteps = (protocolId) => {
    const steps = {
      'dot': [
        {
          step: 1,
          title: 'Step 1: Client Prepares DNS Query',
          description: 'User\'s device wants to resolve "example.com". Client creates standard DNS query packet (Question: example.com, Type: A record). Query is prepared but NOT yet sent - waiting for secure channel.',
          actors: ['client'],
          packetState: 'prepared',
          encrypted: false,
          technicalDetails: 'ðŸ“‹ DNS Query Structure:\nâ€¢ Domain: example.com\nâ€¢ Type: A (IPv4 address)\nâ€¢ Class: IN (Internet)\nâ€¢ Transaction ID: 0x4a2b (random)\nâ€¢ Flags: RD=1 (recursion desired)\nâ€¢ Status: Ready to transmit\n\nðŸ”“ Current State: UNENCRYPTED\nâ€¢ Query visible in plain text\nâ€¢ Vulnerable to interception\nâ€¢ ISP/network can read domain name',
          highlight: 'client'
        },
        {
          step: 2,
          title: 'Step 2: TLS Handshake Established',
          description: 'Client initiates TCP connection to DNS resolver on port 853 (DoT dedicated port). TLS handshake completes: ClientHello, ServerHello, certificate exchange. Encryption keys negotiated using TLS 1.3 protocol. Secure channel ready for encryption.',
          actors: ['client', 'resolver'],
          packetState: 'handshake',
          encrypted: false,
          technicalDetails: 'ðŸ¤ TLS Handshake Process:\n1. TCP 3-way handshake (SYN, SYN-ACK, ACK)\n2. ClientHello: Supported cipher suites, TLS version\n3. ServerHello: Selected cipher (e.g., TLS_AES_256_GCM_SHA384)\n4. Certificate: Resolver presents X.509 certificate\n5. Key Exchange: ECDHE (Elliptic Curve Diffie-Hellman)\n6. Finished: Both sides confirm encryption ready\n\nðŸ” Security Parameters:\nâ€¢ Protocol: TLS 1.3\nâ€¢ Cipher: AES-256-GCM\nâ€¢ Key Exchange: X25519\nâ€¢ Certificate Validation: Chain of trust verified\nâ€¢ Port: 853 (dedicated DoT port)\n\nâ±ï¸ Handshake Time: ~50-100ms',
          highlight: 'resolver'
        },
        {
          step: 3,
          title: 'Step 3: Client Encrypts DNS Query',
          description: 'Client takes the plain DNS query and encrypts it using TLS session keys. DNS packet wrapped in TLS record layer on client side. Lock icon appears showing encryption applied. Query transformed from plain text to encrypted ciphertext.',
          actors: ['client'],
          packetState: 'encrypting',
          encrypted: true,
          technicalDetails: 'ðŸ”’ Encryption Process (Client Side):\nâ€¢ Original DNS query: 29 bytes (plain)\nâ€¢ TLS Record Header added: 5 bytes\nâ€¢ Encryption applied: AES-256-GCM\nâ€¢ Authentication Tag: 16 bytes (GCM)\nâ€¢ Result: 50 bytes encrypted packet\n\nðŸ›¡ï¸ Encryption Applied:\nâ€¢ Domain "example.com" â†’ encrypted bytes\nâ€¢ Query type "A record" â†’ encrypted\nâ€¢ All DNS data â†’ ciphertext\nâ€¢ Ready for secure transmission\n\nðŸ” Security Status:\nâ€¢ Confidentiality: âœ… Encrypted\nâ€¢ Integrity: âœ… Authentication tag added\nâ€¢ Authentication: âœ… TLS session verified\n\nðŸ‘ï¸ What Packet Contains:\nâ€¢ Random-looking encrypted data\nâ€¢ No readable domain name\nâ€¢ Protected query ready to send',
          highlight: 'client'
        },
        {
          step: 4,
          title: 'Step 4: Encrypted Query Transmitted',
          description: 'Encrypted DNS packet sent from client to resolver over the secure TLS channel. Network observers see only encrypted traffic on port 853. Lock icon travels with packet showing it remains encrypted during transit.',
          actors: ['client', 'resolver'],
          packetState: 'transmitting',
          encrypted: true,
          technicalDetails: 'ðŸ“¡ Transmission (Encrypted):\nâ€¢ Source: Client\nâ€¢ Destination: DNS Resolver (port 853)\nâ€¢ Protocol: TLS 1.3 Application Data\nâ€¢ Size: 50 bytes (encrypted)\n\nðŸ‘ï¸ What Network Can See:\nâ€¢ Destination IP: 1.1.1.1 (Cloudflare DNS)\nâ€¢ Port: 853 (identifies DoT traffic)\nâ€¢ Encrypted data: Unreadable random bytes\nâ€¢ Packet length: 50 bytes (visible)\n\nðŸ‘ï¸ What Network CANNOT See:\nâ€¢ Domain name (example.com) - fully encrypted\nâ€¢ Query type (A record) - fully encrypted\nâ€¢ Any DNS content - protected by TLS\nâ€¢ User browsing intent - hidden\n\nðŸ›¡ï¸ Privacy Protection:\nâ€¢ ISP cannot log domain names\nâ€¢ Network admin cannot see queries\nâ€¢ Man-in-the-middle cannot read data\nâ€¢ Censorship cannot filter by domain',
          highlight: 'encrypted-packet'
        },
        {
          step: 5,
          title: 'Step 5: Resolver Decrypts & Resolves',
          description: 'Resolver receives encrypted packet and decrypts using TLS session key. Extracts original question: "example.com A record?". Resolver performs standard DNS lookup (checks cache, queries authoritative servers). Prepares DNS response with IP address.',
          actors: ['resolver', 'auth-server'],
          packetState: 'processing',
          encrypted: false,
          technicalDetails: 'ðŸ”“ Decryption & Processing:\nâ€¢ TLS session key used to decrypt\nâ€¢ Original query extracted: example.com (A)\nâ€¢ Resolver checks local cache\nâ€¢ If not cached: Queries root â†’ TLD â†’ authoritative\n\nðŸ“Š DNS Resolution:\nâ€¢ Cache status: MISS\nâ€¢ Query path: Root NS â†’ .com TLD â†’ example.com auth\nâ€¢ Answer received: 93.184.216.34\nâ€¢ Additional: TTL=86400s (24 hours)\n\nðŸ” Security Note:\nâ€¢ Resolverâ†’Authoritative: May be UNENCRYPTED (standard DNS)\nâ€¢ DoT only encrypts clientâ†”resolver segment\nâ€¢ For end-to-end security: Combine with DNSSEC',
          highlight: 'resolver'
        },
        {
          step: 6,
          title: 'Step 6: Resolver Encrypts Response',
          description: 'Resolver encrypts DNS response (IP: 93.184.216.34) using same TLS session on resolver side. Response packet wrapped in TLS encryption. Lock icon shows response is encrypted before sending back.',
          actors: ['resolver'],
          packetState: 'encrypting',
          encrypted: true,
          technicalDetails: 'ðŸ”’ Response Encryption (Resolver Side):\nâ€¢ DNS Answer: example.com â†’ 93.184.216.34\nâ€¢ TTL: 86400 seconds (24 hours)\nâ€¢ Encryption with TLS session key\nâ€¢ Authentication tag prevents tampering\n\nðŸ“¦ Encrypted Response Packet:\nâ€¢ TLS Record Type: Application Data\nâ€¢ Encrypted DNS response: 45 bytes\nâ€¢ GCM Authentication Tag: 16 bytes\nâ€¢ Total size: ~66 bytes encrypted\n\nðŸ›¡ï¸ Protection Applied:\nâ€¢ IP address encrypted\nâ€¢ Response integrity protected\nâ€¢ Ready for secure transmission',
          highlight: 'resolver'
        },
        {
          step: 7,
          title: 'Step 7: Encrypted Response Transmitted',
          description: 'Encrypted response sent from resolver back to client over TLS channel. Lock icon travels with packet. Network observers see only encrypted data returning to client.',
          actors: ['resolver', 'client'],
          packetState: 'transmitting',
          encrypted: true,
          technicalDetails: 'ðŸ“¡ Return Transmission (Encrypted):\nâ€¢ Source: Resolver\nâ€¢ Destination: Client\nâ€¢ Protocol: TLS 1.3 Application Data\nâ€¢ Size: ~66 bytes encrypted\n\nðŸ›¡ï¸ Protection During Transit:\nâ€¢ ISP cannot see IP address returned\nâ€¢ Man-in-the-middle cannot modify response\nâ€¢ Network observers see only encrypted data\nâ€¢ DNS answer fully protected',
          highlight: 'encrypted-packet'
        },
        {
          step: 8,
          title: 'Step 8: Client Decrypts & Uses Answer',
          description: 'Client receives encrypted response and decrypts using TLS key. Extracts IP address: 93.184.216.34. Validates integrity using authentication tag. Client can now connect to example.com using resolved IP.',
          actors: ['client'],
          packetState: 'complete',
          encrypted: false,
          technicalDetails: 'âœ… Decryption & Validation:\nâ€¢ TLS session key decrypts response\nâ€¢ GCM tag verified (ensures no tampering)\nâ€¢ DNS answer extracted: 93.184.216.34\nâ€¢ Cached locally with TTL\n\nðŸŽ¯ Final Result:\nâ€¢ Domain: example.com\nâ€¢ IP Address: 93.184.216.34\nâ€¢ Cached for: 86400 seconds\nâ€¢ Security: Full privacy maintained\n\nðŸŒ Next Steps:\nâ€¢ Client initiates HTTPS to 93.184.216.34\nâ€¢ TLS handshake for website (separate from DoT)\nâ€¢ Secure browsing session begins\n\nâœ… Privacy Achieved:\nâ€¢ ISP never saw "example.com" query\nâ€¢ Network admin cannot log DNS requests\nâ€¢ Government surveillance cannot intercept\nâ€¢ DNS hijacking prevented',
          highlight: 'client'
        }
      ],

      'doh': [
        {
          step: 1,
          title: 'Step 1: Client Creates DNS Query',
          description: 'Browser/app prepares DNS query for "example.com A record". Query formatted as binary DNS message (wire format). Query ready but not yet sent - waiting for HTTPS encapsulation.',
          actors: ['client'],
          packetState: 'prepared',
          encrypted: false,
          technicalDetails: 'ðŸ“‹ DNS Query (Binary Format):\nâ€¢ Header: 12 bytes (ID, flags, counts)\nâ€¢ Question: example.com, Type A, Class IN\nâ€¢ Total size: 29 bytes (binary DNS message)\nâ€¢ Format: RFC 1035 wire format\n\nðŸ”“ Current State: UNENCRYPTED\nâ€¢ Plain DNS message in memory\nâ€¢ Not yet transmitted\nâ€¢ Waiting for HTTP/TLS wrapper',
          highlight: 'client'
        },
        {
          step: 2,
          title: 'Step 2: HTTPS/TLS Connection Setup',
          description: 'Client establishes HTTPS connection to DoH resolver (e.g., https://cloudflare-dns.com/dns-query) on port 443. Standard TLS 1.3 handshake with web server. Connection looks identical to regular web browsing.',
          actors: ['client', 'resolver'],
          packetState: 'handshake',
          encrypted: false,
          technicalDetails: 'ðŸŒ HTTPS Connection:\nâ€¢ URL: https://1.1.1.1/dns-query\nâ€¢ Port: 443 (standard HTTPS)\nâ€¢ Protocol: HTTP/2 or HTTP/3\nâ€¢ TLS Version: 1.3\n\nðŸ¤ TLS Handshake:\n1. TCP connection to port 443\n2. ClientHello with ALPN (h2, http/1.1)\n3. Server certificate validation\n4. Key exchange (ECDHE-X25519)\n5. Cipher selected: TLS_AES_128_GCM_SHA256\n\nðŸŽ­ Indistinguishability:\nâ€¢ Network sees: HTTPS to cloudflare-dns.com\nâ€¢ Cannot distinguish from web browsing\nâ€¢ Bypasses DNS-specific filtering\nâ€¢ Works through corporate proxies',
          highlight: 'resolver'
        },
        {
          step: 3,
          title: 'Step 3: DNS Query Encapsulated in HTTPS',
          description: 'DNS query wrapped in HTTP POST/GET request. Content-Type: application/dns-message (binary DNS in HTTP body). HTTP headers added, then entire request encrypted by TLS. Triple layer: DNS â†’ HTTP â†’ TLS encryption.',
          actors: ['client', 'resolver'],
          packetState: 'encapsulated',
          encrypted: true,
          technicalDetails: 'ðŸ“¨ HTTP Request Structure:\nPOST /dns-query HTTP/2\nHost: cloudflare-dns.com\nContent-Type: application/dns-message\nContent-Length: 29\nAccept: application/dns-message\n\n[Binary DNS query: 29 bytes]\n\nðŸŽ Encapsulation Layers:\n1. DNS Query (29 bytes) - Core data\n2. HTTP Request (~100 bytes) - Transport wrapper\n3. TLS Encryption - Security layer\n4. TCP/IP - Network delivery\n\nðŸ”’ Encryption Applied:\nâ€¢ Entire HTTP request encrypted by TLS\nâ€¢ DNS query doubly hidden (HTTP body + TLS)\nâ€¢ Headers encrypted too\nâ€¢ Total encrypted payload: ~130 bytes\n\nðŸ›¡ï¸ Privacy Benefits:\nâ€¢ DNS query hidden inside HTTPS\nâ€¢ Looks like regular web traffic\nâ€¢ DPI (Deep Packet Inspection) cannot detect DNS\nâ€¢ Censorship-resistant',
          highlight: 'encrypted-packet'
        },
        {
          step: 4,
          title: 'Step 4: Encrypted Transmission to DoH Resolver',
          description: 'HTTPS request (with DNS inside) transmitted over internet. Network observers see only encrypted HTTPS traffic to cloudflare-dns.com. Cannot distinguish from regular website access. Firewall sees "web browsing" not DNS.',
          actors: ['client', 'resolver'],
          packetState: 'transmitting',
          encrypted: true,
          technicalDetails: 'ðŸŒ Network Visibility:\nðŸ‘ï¸ What ISP/Network Sees:\nâ€¢ Protocol: HTTPS (TLS 1.3)\nâ€¢ Destination: cloudflare-dns.com (1.1.1.1)\nâ€¢ Port: 443 (standard web traffic)\nâ€¢ SNI: cloudflare-dns.com (Server Name Indication)\nâ€¢ Encrypted data stream\n\nðŸš« What ISP/Network CANNOT See:\nâ€¢ DNS query domain (example.com)\nâ€¢ HTTP method (POST)\nâ€¢ Request path (/dns-query)\nâ€¢ DNS message content\nâ€¢ Query type or any DNS data\n\nðŸŽ­ Stealth Features:\nâ€¢ Indistinguishable from web browsing\nâ€¢ Same port as HTTPS websites (443)\nâ€¢ Can tunnel through corporate firewalls\nâ€¢ Bypasses DNS-based censorship\nâ€¢ Works on restrictive networks (hotels, airports)',
          highlight: 'encrypted-packet'
        },
        {
          step: 5,
          title: 'Step 5: Resolver Decrypts, Extracts DNS Query',
          description: 'DoH resolver terminates TLS connection and decrypts HTTPS request. Extracts HTTP headers, reads Content-Type: application/dns-message. Unwraps HTTP body to get binary DNS query. Performs standard DNS resolution.',
          actors: ['resolver', 'auth-server'],
          packetState: 'processing',
          encrypted: false,
          technicalDetails: 'ðŸ”“ Decryption & Extraction:\n1. TLS layer decrypted\n2. HTTP/2 request parsed\n3. Content-Type verified: application/dns-message\n4. Binary DNS message extracted from body\n5. DNS query decoded: example.com (A)\n\nðŸ“Š DNS Resolution:\nâ€¢ Resolver checks cache: MISS\nâ€¢ Queries root nameserver\nâ€¢ Queries .com TLD nameserver\nâ€¢ Queries example.com authoritative\nâ€¢ Receives answer: 93.184.216.34\n\nâš ï¸ Security Note:\nâ€¢ Resolverâ†’Auth may use plain DNS (port 53)\nâ€¢ DoH only secures clientâ†’resolver\nâ€¢ Resolver sees all your queries (trust required)\nâ€¢ Combine with DNSSEC for authenticity',
          highlight: 'resolver'
        },
        {
          step: 6,
          title: 'Step 6: Resolver Rewraps Answer in HTTPS',
          description: 'Resolver creates DNS response (IP: 93.184.216.34). Formats as binary DNS message. Wraps in HTTP response with Content-Type: application/dns-message. Encrypts entire HTTP response with TLS.',
          actors: ['resolver', 'client'],
          packetState: 'encapsulated',
          encrypted: true,
          technicalDetails: 'ðŸ“¨ HTTP Response Structure:\nHTTP/2 200 OK\nContent-Type: application/dns-message\nContent-Length: 45\nCache-Control: max-age=86400\n\n[Binary DNS response: 45 bytes]\n\nðŸ”’ Response Encryption:\nâ€¢ DNS answer: example.com â†’ 93.184.216.34\nâ€¢ TTL: 86400 seconds\nâ€¢ Wrapped in HTTP/2 response\nâ€¢ Encrypted by TLS session\nâ€¢ Total encrypted size: ~150 bytes\n\nðŸ›¡ï¸ Security Layers (Reverse):\n1. TLS encryption applied\n2. HTTP response wrapper\n3. Binary DNS message inside\n4. Transmitted as HTTPS traffic',
          highlight: 'encrypted-packet'
        },
        {
          step: 7,
          title: 'Step 7: Client Decrypts & Uses DNS Response',
          description: 'Client receives encrypted HTTPS response. TLS layer decrypted using session key. HTTP response parsed, DNS message extracted from body. IP address 93.184.216.34 cached and ready for use. Browser connects to website.',
          actors: ['client'],
          packetState: 'complete',
          encrypted: false,
          technicalDetails: 'âœ… Decryption & Extraction:\n1. TLS decryption with session key\n2. HTTP/2 response parsed\n3. Content-Type validated\n4. Binary DNS message extracted\n5. DNS answer decoded: 93.184.216.34\n6. Cached with TTL=86400s\n\nðŸŽ¯ Final Result:\nâ€¢ Domain: example.com\nâ€¢ IP Address: 93.184.216.34\nâ€¢ Cached for: 24 hours\nâ€¢ Privacy: Fully protected\n\nðŸŒ Next Steps:\nâ€¢ Browser initiates HTTPS to 93.184.216.34\nâ€¢ Website loads securely\nâ€¢ All DNS queries protected by DoH\n\nâœ… Privacy Achieved:\nâ€¢ Complete DNS query privacy\nâ€¢ Indistinguishable from web browsing\nâ€¢ Censorship-resistant\nâ€¢ Works on restricted networks\nâ€¢ ISP/network blind to DNS activity',
          highlight: 'client'
        }
      ],

      'dnssec': [
        {
          step: 1,
          title: 'Step 1: Client/Resolver Sends DNS Query',
          description: 'Client requests "example.com A record" from DNSSEC-validating resolver. Query includes DO (DNSSEC OK) flag requesting signed responses. Query can use plain DNS (port 53), DoT, or DoH - DNSSEC works with all.',
          actors: ['client', 'resolver'],
          packetState: 'query',
          encrypted: false,
          dnssec: true,
          technicalDetails: 'ðŸ“‹ DNSSEC-Enabled Query:\nâ€¢ Domain: example.com\nâ€¢ Type: A (IPv4 address)\nâ€¢ Class: IN\nâ€¢ DO Flag: 1 (DNSSEC OK - requesting signatures)\nâ€¢ AD Flag: 0 (not yet authenticated)\nâ€¢ CD Flag: 0 (checking enabled)\n\nðŸ” DNSSEC Request:\nâ€¢ Client signals DNSSEC support\nâ€¢ Resolver knows to validate signatures\nâ€¢ Additional query: Also request RRSIG records\n\nâš ï¸ Important:\nâ€¢ DNSSEC ensures AUTHENTICITY not privacy\nâ€¢ Query still visible if using plain DNS\nâ€¢ Combine with DoT/DoH for privacy + authenticity\nâ€¢ Transport: Can be UDP/TCP/TLS/HTTPS',
          highlight: 'client'
        },
        {
          step: 2,
          title: 'Step 2: DNS Server Responds with Signed Data',
          description: 'Authoritative server returns DNS answer PLUS cryptographic signatures. Response includes: A record (IP address), RRSIG (signature), DNSKEY (public key). Signature created using zone\'s private key. Multiple records for chain of trust.',
          actors: ['auth-server', 'resolver'],
          packetState: 'signed-response',
          encrypted: false,
          dnssec: true,
          technicalDetails: 'ðŸ“œ DNSSEC Response Structure:\n\n1. Answer Section:\n   example.com. 86400 IN A 93.184.216.34\n\n2. RRSIG (Signature):\n   example.com. 86400 IN RRSIG A 8 2 86400 (\n     20241201000000 20241101000000 12345 example.com.\n     [Base64 signature: 256 bytes]\n   )\n\n3. DNSKEY (Public Key):\n   example.com. 86400 IN DNSKEY 257 3 8 (\n     [Base64 public key: 256 bytes]\n   )\n\nðŸ” Signature Details:\nâ€¢ Algorithm: RSA/SHA-256 (DNSSEC alg 8)\nâ€¢ Key Tag: 12345 (identifies signing key)\nâ€¢ Inception: 2024-11-01 (signature valid from)\nâ€¢ Expiration: 2024-12-01 (signature valid until)\nâ€¢ Signer: example.com\nâ€¢ Signature: Encrypts hash of A record with private key\n\nðŸ”— Chain of Trust:\nâ€¢ Root zone â†’ .com TLD â†’ example.com\nâ€¢ Each level signs the next level\'s DNSKEY\nâ€¢ Trust anchor: Root zone public key (embedded in resolver)',
          highlight: 'auth-server'
        },
        {
          step: 3,
          title: 'Step 3: Resolver Verifies Signature Chain',
          description: 'Resolver validates DNSSEC chain of trust. Starts from root zone trust anchor. Validates .com TLD signature, then example.com signature. Uses public keys to verify signatures. Checks expiration dates and algorithm compatibility.',
          actors: ['resolver'],
          packetState: 'validating',
          encrypted: false,
          dnssec: true,
          technicalDetails: 'ðŸ” Validation Process:\n\n1. Root Zone Validation:\n   â€¢ Resolver has root DNSKEY (trust anchor)\n   â€¢ Validates DS record for .com TLD\n   â€¢ DS = hash of .com DNSKEY\n\n2. TLD (.com) Validation:\n   â€¢ Fetch .com DNSKEY using validated DS\n   â€¢ Validates DS record for example.com\n   â€¢ Chain extended to example.com\n\n3. Domain (example.com) Validation:\n   â€¢ Fetch example.com DNSKEY\n   â€¢ Verify RRSIG signature on A record\n   â€¢ Decrypt signature with public key\n   â€¢ Compare hash with actual A record hash\n\nðŸ” Cryptographic Verification:\nâ€¢ RRSIG signature decrypted with DNSKEY (public key)\nâ€¢ Result: Hash of original A record\nâ€¢ Compute hash of received A record (93.184.216.34)\nâ€¢ Hashes match? âœ… Authentic | âŒ Tampered\n\nâ° Validity Checks:\nâ€¢ Signature inception: 2024-11-01 âœ…\nâ€¢ Signature expiration: 2024-12-01 âœ…\nâ€¢ Current date: 2024-11-12 âœ… (within range)\nâ€¢ Algorithm supported: RSA/SHA-256 âœ…\n\nâœ… Validation Result: SECURE\nâ€¢ All signatures valid\nâ€¢ Chain of trust intact\nâ€¢ No tampering detected',
          highlight: 'resolver'
        },
        {
          step: 4,
          title: 'Step 4: Client Receives Validated Answer or Error',
          description: 'If DNSSEC validation succeeds: Client receives IP with AD (Authenticated Data) flag set. Green checkmark indicates verified answer. If validation fails: Resolver returns SERVFAIL error. Red X indicates potential attack or misconfiguration.',
          actors: ['resolver', 'client'],
          packetState: 'complete',
          encrypted: false,
          dnssec: true,
          technicalDetails: 'âœ… SUCCESSFUL VALIDATION:\nâ€¢ Response flags: AD=1 (Authenticated Data)\nâ€¢ Answer: example.com â†’ 93.184.216.34\nâ€¢ Status: SECURE (cryptographically verified)\nâ€¢ Client can trust IP address is correct\n\nðŸŽ¯ What DNSSEC Guarantees:\nâ€¢ âœ… Authenticity: Answer from legitimate nameserver\nâ€¢ âœ… Integrity: Data not modified in transit\nâ€¢ âœ… Non-repudiation: Server cannot deny sending response\nâ€¢ âŒ Privacy: Query still visible (use DoT/DoH for privacy)\n\nâŒ VALIDATION FAILURE SCENARIOS:\n\n1. Signature Mismatch (Attack Detected):\n   â€¢ RRSIG decryption doesn\'t match data hash\n   â€¢ Possible DNS cache poisoning attempt\n   â€¢ Resolver returns: SERVFAIL\n   â€¢ Client gets: No answer + error\n\n2. Expired Signature:\n   â€¢ Current date outside inception-expiration range\n   â€¢ Zone admin forgot to re-sign\n   â€¢ Resolver returns: SERVFAIL\n\n3. Broken Chain of Trust:\n   â€¢ Missing DS record at parent zone\n   â€¢ DNSKEY doesn\'t match DS hash\n   â€¢ Resolver returns: SERVFAIL\n\n4. BOGUS Status:\n   â€¢ Validation actively failed (attack likely)\n   â€¢ Resolver logs security event\n   â€¢ Client connection blocked\n\nðŸ”’ Security Benefits:\nâ€¢ Prevents Kaminsky-style cache poisoning\nâ€¢ Detects man-in-the-middle attacks\nâ€¢ Ensures DNS data integrity\nâ€¢ Cryptographically proves authenticity\n\nâš ï¸ Limitations:\nâ€¢ Doesn\'t encrypt queries (use DoT/DoH)\nâ€¢ Only ~30% of domains support DNSSEC\nâ€¢ Resolver must be DNSSEC-validating\nâ€¢ Adds ~2-5KB per response (signatures)',
          highlight: 'client'
        }
      ]
    };

    return steps[protocolId] || [];
  };

  const drawSecurityVisualization = () => {
    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();

    const width = svgRef.current.clientWidth;
    const height = svgRef.current.clientHeight || 800;

    const g = svg
      .attr('width', width)
      .attr('height', height)
      .append('g');

    const steps = getProtocolSteps(selectedProtocol);
    if (steps.length === 0) return;

    const currentStep = steps[Math.min(simulationStep, steps.length - 1)];
    const protocol = protocols.find(p => p.id === selectedProtocol);

    // Define positions
    const marginX = 120;
    const marginY = 100;
    const halfWidth = width / 2;
    const halfHeight = height / 2;

    const actorDefinitions = {
      'client': {
        x: marginX + 50,
        y: halfHeight,
        color: '#3b82f6',
        icon: 'ðŸ’»',
        label: 'Client'
      },
      'resolver': {
        x: width - marginX - 50,
        y: halfHeight,
        color: selectedProtocol === 'dnssec' ? '#8b5cf6' : '#10b981',
        icon: selectedProtocol === 'dnssec' ? 'ï¿½' : 'ï¿½ðŸ”’',
        label: selectedProtocol === 'dnssec' ? 'Validating Resolver' : 'DNS Resolver'
      },
      'auth-server': {
        x: width - marginX - 50,
        y: marginY + 80,
        color: '#10b981',
        icon: 'ðŸ“‹',
        label: 'Authoritative Server'
      },
      'packet': {
        x: halfWidth,
        y: halfHeight - 80,
        color: '#94a3b8',
        icon: 'ï¿½',
        label: 'DNS Packet'
      }
    };

    // Draw actors with professional entrance animations
    const activeActors = currentStep.actors || [];
    activeActors.forEach((actorId, index) => {
      const actor = actorDefinitions[actorId];
      if (!actor) return;

      const actorGroup = g.append('g')
        .attr('class', 'actor-group')
        .style('cursor', 'pointer')
        .on('click', () => handleNodeClick(actorId, simulationStep));

      // Glow effect for highlighted actors (appears after actor)
      if (currentStep.highlight === actorId) {
        const glow = actorGroup.append('circle')
          .attr('cx', actor.x)
          .attr('cy', actor.y)
          .attr('r', 70)
          .attr('fill', 'none')
          .attr('stroke', protocol.color)
          .attr('stroke-width', 3)
          .attr('opacity', 0)
          .attr('class', 'actor-glow')
          .attr('stroke-dasharray', '5,5');

        glow.transition()
          .delay(index * 120 + 500)
          .duration(600)
          .ease(d3.easeCubicInOut)
          .attr('opacity', 0.7);
      }

      // Actor circle with entrance animation (grow from 0)
      const circle = actorGroup.append('circle')
        .attr('cx', actor.x)
        .attr('cy', actor.y)
        .attr('r', 0)
        .attr('fill', actor.color)
        .attr('stroke', '#fff')
        .attr('stroke-width', 3)
        .attr('opacity', 0);

      circle.transition()
        .delay(index * 120)
        .duration(600)
        .ease(d3.easeBackOut)
        .attr('r', 55)
        .attr('opacity', 0.9);

      // Actor icon (fades in after circle)
      const icon = actorGroup.append('text')
        .attr('x', actor.x)
        .attr('y', actor.y + 12)
        .attr('text-anchor', 'middle')
        .attr('font-size', '36px')
        .attr('opacity', 0)
        .text(actor.icon);

      icon.transition()
        .delay(index * 120 + 300)
        .duration(500)
        .ease(d3.easeCubicInOut)
        .attr('opacity', 1);

      // Actor label (appears last)
      const label = actorGroup.append('text')
        .attr('x', actor.x)
        .attr('y', actor.y + 90)
        .attr('text-anchor', 'middle')
        .attr('fill', '#fff')
        .attr('font-size', '14px')
        .attr('font-weight', '700')
        .attr('opacity', 0)
        .text(actor.label);

      label.transition()
        .delay(index * 120 + 450)
        .duration(500)
        .ease(d3.easeCubicInOut)
        .attr('opacity', 1);
    });

    // Draw animated packets with connections (new packet animation logic)
    const packetFlows = getPacketFlows(selectedProtocol, currentStep.step);
    if (packetFlows && packetFlows.length > 0) {
      packetFlows.forEach((flow, flowIndex) => {
        const fromActor = actorDefinitions[flow.from];
        const toActor = actorDefinitions[flow.to];
        
        if (!fromActor || !toActor) return;

        // Handle self-loops (internal processing)
        if (fromActor === toActor || flow.self) {
          const centerX = fromActor.x;
          const centerY = fromActor.y;
          const loopRadius = 50;

          // Circular path with animation
          const loopPath = g.append('path')
            .attr('d', `M ${centerX} ${centerY - 20} A ${loopRadius} ${loopRadius} 0 1 1 ${centerX + 1} ${centerY - 20}`)
            .attr('fill', 'none')
            .attr('stroke', flow.encrypting || flow.encrypted || flow.dnssec ? protocol.color : flow.decrypting ? '#f59e0b' : '#94a3b8')
            .attr('stroke-width', flow.encrypting || flow.encrypted || flow.dnssec ? 4 : 3)
            .attr('stroke-dasharray', '10,5')
            .attr('opacity', 0)
            .attr('class', 'processing-loop');

          loopPath.transition()
            .delay(flowIndex * 600 + 800)
            .duration(400)
            .attr('opacity', 0.7);

          // Determine processing icon based on operation
          let icon = 'âš™ï¸';
          let iconColor = '#fbbf24';
          if (flow.encrypting) {
            icon = 'ðŸ”’';
            iconColor = protocol.color;
          } else if (flow.decrypting) {
            icon = 'ðŸ”“';
            iconColor = '#f59e0b';
          } else if (flow.validating || flow.verifying) {
            icon = 'ðŸ”';
            iconColor = '#8b5cf6';
          } else if (flow.encapsulating) {
            icon = 'ðŸ“¦';
            iconColor = '#3b82f6';
          } else if (flow.extracting) {
            icon = 'ðŸ“¤';
            iconColor = '#10b981';
          } else if (flow.preparing) {
            icon = 'ï¿½';
            iconColor = '#64748b';
          }

          // Processing icon with pulse animation
          const processingIcon = g.append('text')
            .attr('x', centerX)
            .attr('y', centerY - 70)
            .attr('text-anchor', 'middle')
            .attr('font-size', '2rem')
            .attr('opacity', 0)
            .attr('class', 'processing-icon')
            .text(icon);

          processingIcon.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(300)
            .attr('opacity', 1)
            .transition()
            .duration(500)
            .attr('font-size', '2.3rem')
            .transition()
            .duration(500)
            .attr('font-size', '2rem');

          // Label with background
          const labelText = flow.label || 'Processing...';
          const labelWidth = Math.max(140, labelText.length * 8);
          
          const labelBg = g.append('rect')
            .attr('x', centerX - labelWidth/2)
            .attr('y', centerY - 105)
            .attr('width', labelWidth)
            .attr('height', 24)
            .attr('rx', 12)
            .attr('fill', iconColor)
            .attr('opacity', 0);

          labelBg.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(300)
            .attr('opacity', 0.9);

          const label = g.append('text')
            .attr('x', centerX)
            .attr('y', centerY - 90)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.8rem')
            .attr('font-weight', '700')
            .attr('fill', '#fff')
            .attr('opacity', 0)
            .text(labelText);

          label.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(300)
            .attr('opacity', 1);

          // Add status indicator for encryption/decryption
          if (flow.encrypting || flow.decrypting) {
            const statusGroup = g.append('g').attr('class', 'status-indicator');
            
            statusGroup.append('circle')
              .attr('cx', centerX + 45)
              .attr('cy', centerY - 70)
              .attr('r', 14)
              .attr('fill', flow.encrypting ? '#10b981' : '#f59e0b')
              .attr('stroke', '#fff')
              .attr('stroke-width', 2)
              .attr('opacity', 0)
              .transition()
              .delay(flowIndex * 600 + 1400)
              .duration(300)
              .attr('opacity', 1);

            statusGroup.append('text')
              .attr('x', centerX + 45)
              .attr('y', centerY - 70)
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'middle')
              .attr('font-size', '0.9rem')
              .attr('fill', '#fff')
              .attr('font-weight', 'bold')
              .attr('opacity', 0)
              .text(flow.encrypting ? 'ðŸ”' : 'ðŸ”“')
              .transition()
              .delay(flowIndex * 600 + 1400)
              .duration(300)
              .attr('opacity', 1);
          }
        } else {
          // Packet traveling between actors
          const offsetY = flowIndex * 15 - 15;
          const midX = (fromActor.x + toActor.x) / 2;
          const midY = (fromActor.y + toActor.y) / 2 + offsetY;

          // Connection line (animated)
          const line = g.append('line')
            .attr('x1', fromActor.x)
            .attr('y1', fromActor.y)
            .attr('x2', fromActor.x)
            .attr('y2', fromActor.y)
            .attr('stroke', flow.encrypted || flow.dnssec ? protocol.color : '#64748b')
            .attr('stroke-width', flow.encrypted || flow.dnssec ? 4 : 3)
            .attr('stroke-dasharray', flow.encrypted || flow.dnssec ? '0' : '8,4')
            .attr('opacity', 0)
            .attr('class', 'connection-line');

          line.transition()
            .delay(flowIndex * 600 + 800)
            .duration(400)
            .attr('opacity', 0.6)
            .transition()
            .duration(1200)
            .attr('x2', toActor.x)
            .attr('y2', toActor.y);

          // Create clickable packet
          const packetGroup = g.append('g')
            .attr('class', `packet-node packet-${flowIndex}`)
            .attr('transform', `translate(${fromActor.x}, ${fromActor.y})`)
            .style('cursor', 'pointer')
            .attr('opacity', 0)
            .on('click', () => handlePacketClick());

          // Determine packet appearance based on state
          let packetColor = '#94a3b8'; // default gray
          let packetIcon = 'ðŸ“¦';
          let strokeColor = '#fff';
          
          if (flow.encrypted || flow.transmitting && flow.encrypted) {
            packetColor = protocol.color;
            packetIcon = 'ðŸ”’';
          } else if (flow.dnssec) {
            packetColor = '#8b5cf6';
            packetIcon = 'âœ…';
          } else if (flow.isHTTPS) {
            packetColor = '#3b82f6';
            packetIcon = 'ðŸŒ';
          } else if (flow.handshake) {
            packetColor = '#fbbf24';
            packetIcon = 'ðŸ¤';
          } else if (flow.resolving) {
            packetColor = '#64748b';
            packetIcon = 'ðŸ“¡';
          }

          // Packet envelope with glow effect for encrypted packets
          const packetRect = packetGroup.append('rect')
            .attr('x', -20)
            .attr('y', -20)
            .attr('width', 40)
            .attr('height', 40)
            .attr('rx', 6)
            .attr('fill', packetColor)
            .attr('stroke', strokeColor)
            .attr('stroke-width', 2)
            .style('filter', flow.encrypted ? 'drop-shadow(0 0 12px ' + packetColor + ') drop-shadow(0 2px 8px rgba(0,0,0,0.3))' : 'drop-shadow(0 2px 8px rgba(0,0,0,0.3))');

          // Packet icon
          packetGroup.append('text')
            .attr('x', 0)
            .attr('y', 0)
            .attr('text-anchor', 'middle')
            .attr('dominant-baseline', 'middle')
            .attr('font-size', '1.3rem')
            .text(packetIcon);

          // Special badge for encrypted/signed/validated packets
          if (flow.encrypted || flow.dnssec || flow.signed || flow.validated) {
            const badgeGroup = packetGroup.append('g').attr('class', 'packet-badge');
            
            let badgeColor = protocol.color;
            let badgeIcon = 'ðŸ”';
            
            if (flow.validated) {
              badgeColor = '#10b981';
              badgeIcon = 'âœ“';
            } else if (flow.signed) {
              badgeColor = '#8b5cf6';
              badgeIcon = 'âœ…';
            } else if (flow.encrypted) {
              badgeColor = protocol.color;
              badgeIcon = 'ðŸ”';
            }
            
            badgeGroup.append('circle')
              .attr('cx', 15)
              .attr('cy', -15)
              .attr('r', 12)
              .attr('fill', badgeColor)
              .attr('stroke', '#fff')
              .attr('stroke-width', 2);

            badgeGroup.append('text')
              .attr('x', 15)
              .attr('y', -15)
              .attr('text-anchor', 'middle')
              .attr('dominant-baseline', 'middle')
              .attr('font-size', '0.75rem')
              .attr('fill', '#fff')
              .attr('font-weight', 'bold')
              .text(badgeIcon);
          }

          // Packet label
          const labelWidth = Math.max(120, flow.label.length * 7);
          
          const labelBg = g.append('rect')
            .attr('x', fromActor.x - labelWidth/2)
            .attr('y', fromActor.y - 50)
            .attr('width', labelWidth)
            .attr('height', 20)
            .attr('rx', 4)
            .attr('fill', flow.encrypted || flow.dnssec ? `${protocol.color}40` : 'rgba(59, 130, 246, 0.2)')
            .attr('stroke', flow.encrypted || flow.dnssec ? protocol.color : '#3b82f6')
            .attr('stroke-width', 1)
            .attr('opacity', 1);

          const label = g.append('text')
            .attr('x', fromActor.x)
            .attr('y', fromActor.y - 35)
            .attr('text-anchor', 'middle')
            .attr('font-size', '0.75rem')
            .attr('font-weight', '600')
            .attr('fill', flow.encrypted || flow.dnssec ? protocol.color : '#93c5fd')
            .attr('opacity', 1)
            .text(flow.label);

          // Animate packet movement
          packetGroup.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(300)
            .attr('opacity', 1)
            .transition()
            .duration(1500)
            .attr('transform', `translate(${toActor.x}, ${toActor.y})`)
            .on('end', function() {
              // Pulse on arrival
              d3.select(this).select('rect')
                .transition()
                .duration(200)
                .attr('width', 50)
                .attr('height', 50)
                .attr('x', -25)
                .attr('y', -25)
                .transition()
                .duration(200)
                .attr('width', 40)
                .attr('height', 40)
                .attr('x', -20)
                .attr('y', -20);
            });

          // Move label with packet
          labelBg.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(1500)
            .attr('x', toActor.x - labelWidth/2)
            .attr('y', toActor.y - 50);

          label.transition()
            .delay(flowIndex * 600 + 1200)
            .duration(1500)
            .attr('x', toActor.x)
            .attr('y', toActor.y - 35);
        }
      });
    }

    // Step indicator badge with entrance animation
    const stepBadge = g.append('g').attr('opacity', 0);
    
    stepBadge.append('rect')
      .attr('x', width - 140)
      .attr('y', 20)
      .attr('width', 120)
      .attr('height', 40)
      .attr('fill', protocol.color)
      .attr('rx', 20)
      .attr('opacity', 0.9);

    stepBadge.append('text')
      .attr('x', width - 80)
      .attr('y', 47)
      .attr('text-anchor', 'middle')
      .attr('fill', 'white')
      .attr('font-size', '16px')
      .attr('font-weight', '700')
      .text(`Step ${simulationStep + 1}/${steps.length}`);

    stepBadge.transition()
      .delay(200)
      .duration(500)
      .ease(d3.easeCubicInOut)
      .attr('opacity', 1);

    // Protocol status indicator with entrance animation
    const statusX = 30;
    const statusY = 30;
    
    const statusGroup = g.append('g').attr('opacity', 0);
    
    statusGroup.append('rect')
      .attr('x', statusX)
      .attr('y', statusY)
      .attr('width', 200)
      .attr('height', 50)
      .attr('fill', 'rgba(31, 41, 55, 0.9)')
      .attr('stroke', protocol.color)
      .attr('stroke-width', 2)
      .attr('rx', 10);

    statusGroup.append('text')
      .attr('x', statusX + 10)
      .attr('y', statusY + 22)
      .attr('fill', '#cbd5e1')
      .attr('font-size', '11px')
      .attr('font-weight', '600')
      .text('Protocol Status:');

    const statusText = currentStep.encrypted ? 'ðŸ”’ ENCRYPTED' : 
                      currentStep.dnssec ? 'âœ… SIGNED' :
                      currentStep.packetState === 'handshake' ? 'ðŸ¤ HANDSHAKE' :
                      currentStep.packetState === 'processing' ? 'âš™ï¸ PROCESSING' :
                      'ðŸ“‹ PLAIN';

    statusGroup.append('text')
      .attr('x', statusX + 10)
      .attr('y', statusY + 42)
      .attr('fill', currentStep.encrypted || currentStep.dnssec ? protocol.color : '#94a3b8')
      .attr('font-size', '14px')
      .attr('font-weight', '700')
      .text(statusText);

    statusGroup.transition()
      .delay(300)
      .duration(500)
      .ease(d3.easeCubicInOut)
      .attr('opacity', 1);
  };

  const getPacketFlows = (protocolId, step) => {
    const flows = {
      'dot': {
        // Step 1: Client prepares DNS query (plain, not encrypted yet)
        1: [
          { from: 'client', to: 'client', label: 'ðŸ“‹ DNS Query Prepared', encrypted: false, self: true, preparing: true }
        ],
        // Step 2: TLS Handshake between client and resolver
        2: [
          { from: 'client', to: 'resolver', label: 'ðŸ¤ TLS Handshake', encrypted: false, handshake: true, bidirectional: true }
        ],
        // Step 3: Client encrypts the query locally (self-loop)
        3: [
          { from: 'client', to: 'client', label: 'ðŸ”’ Encrypting Query', encrypted: true, self: true, encrypting: true }
        ],
        // Step 4: Encrypted query transmitted to resolver
        4: [
          { from: 'client', to: 'resolver', label: 'ðŸ” Encrypted DNS Query (TLS)', encrypted: true, transmitting: true }
        ],
        // Step 5: Resolver decrypts and queries authoritative server (separated for clarity)
        5: [
          { from: 'resolver', to: 'resolver', label: 'ðŸ”“ Decrypting Query', encrypted: false, self: true, decrypting: true, 
            decryptDetails: { original: '[Encrypted Bytes]', decrypted: 'example.com (A record)' } },
          { from: 'resolver', to: 'auth-server', label: 'ðŸ“¡ Standard DNS Query', encrypted: false, resolving: true, 
            offsetY: -40 } // Separate vertically
        ],
        // Step 6: Resolver encrypts the response (self-loop)
        6: [
          { from: 'resolver', to: 'resolver', label: 'ðŸ”’ Encrypting Response', encrypted: true, self: true, encrypting: true }
        ],
        // Step 7: Encrypted response transmitted to client
        7: [
          { from: 'resolver', to: 'client', label: 'ðŸ” Encrypted Response (TLS)', encrypted: true, transmitting: true }
        ],
        // Step 8: Client decrypts and uses the answer
        8: [
          { from: 'client', to: 'client', label: 'ðŸ”“ Decrypting Response', encrypted: false, self: true, decrypting: true,
            decryptDetails: { original: '[Encrypted Bytes]', decrypted: '93.184.216.34' } }
        ],
      },
      'doh': {
        // Step 1: Client creates DNS query
        1: [
          { from: 'client', to: 'client', label: 'ï¿½ DNS Query Created', encrypted: false, self: true, preparing: true }
        ],
        // Step 2: HTTPS/TLS connection setup
        2: [
          { from: 'client', to: 'resolver', label: 'ðŸŒ HTTPS/TLS Setup', encrypted: false, handshake: true, bidirectional: true }
        ],
        // Step 3: DNS query encapsulated in HTTPS (encryption happens here)
        3: [
          { from: 'client', to: 'client', label: 'ðŸ“¦ Wrapping in HTTP', encrypted: false, self: true, encapsulating: true },
          { from: 'client', to: 'client', label: 'ðŸ”’ TLS Encryption', encrypted: true, self: true, encrypting: true }
        ],
        // Step 4: Encrypted HTTPS request transmitted
        4: [
          { from: 'client', to: 'resolver', label: 'ðŸ” HTTPS POST (Encrypted)', encrypted: true, isHTTPS: true, transmitting: true }
        ],
        // Step 5: Resolver decrypts HTTPS, extracts DNS, resolves (separated for clarity)
        5: [
          { from: 'resolver', to: 'resolver', label: 'ðŸ”“ TLS Decryption', encrypted: false, self: true, decrypting: true,
            decryptDetails: { original: '[HTTPS Encrypted]', decrypted: 'HTTP POST /dns-query' }, offsetLoop: 0 },
          { from: 'resolver', to: 'resolver', label: 'ðŸ“¤ Extract DNS from HTTP', encrypted: false, self: true, extracting: true,
            offsetLoop: 60 }, // Offset second loop to the right
          { from: 'resolver', to: 'auth-server', label: 'ðŸ“¡ Standard DNS Query', encrypted: false, resolving: true,
            offsetY: -40 } // Offset packet path
        ],
        // Step 6: Resolver wraps response in HTTPS and encrypts
        6: [
          { from: 'resolver', to: 'resolver', label: 'ðŸ“¦ Wrap in HTTP Response', encrypted: false, self: true, encapsulating: true },
          { from: 'resolver', to: 'resolver', label: 'ï¿½ TLS Encryption', encrypted: true, self: true, encrypting: true },
          { from: 'resolver', to: 'client', label: 'ðŸ” HTTP/2 200 OK (Encrypted)', encrypted: true, isHTTPS: true, transmitting: true }
        ],
        // Step 7: Client decrypts and extracts DNS response
        7: [
          { from: 'client', to: 'client', label: 'ðŸ”“ TLS Decryption', encrypted: false, self: true, decrypting: true },
          { from: 'client', to: 'client', label: 'ðŸ“¤ Extract DNS from HTTP', encrypted: false, self: true, extracting: true }
        ],
      },
      'dnssec': {
        // Step 1: Client sends DNS query with DO flag
        1: [
          { from: 'client', to: 'resolver', label: 'ðŸ“‹ DNS Query (DO=1)', dnssec: true, encrypted: false }
        ],
        // Step 2: Authoritative server responds with signatures
        2: [
          { from: 'resolver', to: 'auth-server', label: 'ðŸ“¡ Query Authoritative', encrypted: false, dnssec: true },
          { from: 'auth-server', to: 'resolver', label: 'âœ… Signed Response (RRSIG)', dnssec: true, signed: true }
        ],
        // Step 3: Resolver validates signature chain
        3: [
          { from: 'resolver', to: 'resolver', label: 'ðŸ” Validating Chain', dnssec: true, self: true, validating: true },
          { from: 'resolver', to: 'resolver', label: 'ðŸ” Verify RRSIG', dnssec: true, self: true, verifying: true }
        ],
        // Step 4: Client receives validated answer
        4: [
          { from: 'resolver', to: 'client', label: 'âœ… Validated (AD=1)', dnssec: true, validated: true }
        ],
      }
    };

    return flows[protocolId]?.[step] || [];
  };

  const handleNodeClick = (nodeId, step) => {
    const steps = getProtocolSteps(selectedProtocol);
    const currentStep = steps[step];
    if (currentStep) {
      setSelectedNode({ nodeId, step, data: currentStep });
    }
  };

  const handlePacketClick = () => {
    const steps = getProtocolSteps(selectedProtocol);
    const currentStep = steps[simulationStep];
    
    if (!currentStep) return;

    const protocol = protocols.find(p => p.id === selectedProtocol);
    
    // Generate packet details based on protocol and step
    const details = {
      protocol: protocol.name,
      step: currentStep.step,
      stepTitle: currentStep.title,
      packetState: currentStep.packetState,
      encrypted: currentStep.encrypted || false,
      dnssec: currentStep.dnssec || false
    };

    // Add protocol-specific packet data
    if (selectedProtocol === 'dot') {
      details.packetData = {
        type: 'DNS over TLS',
        transport: 'TCP',
        port: currentStep.step === 1 ? 'N/A (preparing)' : '853',
        encryption: currentStep.encrypted ? 'TLS 1.3 (AES-256-GCM)' : 'None',
        size: currentStep.encrypted ? '~50 bytes (encrypted)' : '29 bytes (plain)',
        headers: {
          transactionId: '0x4a2b',
          flags: 'QR=0, RD=1, AA=0',
          questions: 1,
          answers: currentStep.step >= 4 ? 1 : 0
        },
        query: currentStep.encrypted ? '[ENCRYPTED]' : 'example.com',
        queryType: 'A (IPv4 Address)',
        tlsInfo: currentStep.encrypted ? {
          version: 'TLS 1.3',
          cipher: 'TLS_AES_256_GCM_SHA384',
          keyExchange: 'ECDHE-X25519',
          authentication: 'RSA-PSS',
          recordType: 'Application Data'
        } : null
      };
    } else if (selectedProtocol === 'doh') {
      details.packetData = {
        type: 'DNS over HTTPS',
        transport: 'TCP',
        port: currentStep.step === 1 ? 'N/A (preparing)' : '443',
        protocol: currentStep.step >= 2 ? 'HTTP/2 over TLS 1.3' : 'None',
        encryption: currentStep.encrypted ? 'HTTPS (TLS 1.3)' : 'None',
        size: currentStep.packetState === 'encapsulated' ? '~130 bytes (HTTP+DNS)' : '29 bytes',
        httpHeaders: currentStep.step >= 3 ? {
          method: 'POST',
          path: '/dns-query',
          host: 'cloudflare-dns.com',
          contentType: 'application/dns-message',
          contentLength: currentStep.step >= 6 ? '45' : '29',
          accept: 'application/dns-message',
          userAgent: 'DNS-Client/1.0'
        } : null,
        dnsData: {
          transactionId: '0x4a2b',
          query: currentStep.encrypted ? '[ENCRYPTED]' : 'example.com',
          queryType: 'A (IPv4 Address)',
          format: 'RFC 1035 wire format (binary)'
        },
        tlsInfo: currentStep.encrypted ? {
          version: 'TLS 1.3',
          cipher: 'TLS_AES_128_GCM_SHA256',
          sni: 'cloudflare-dns.com',
          alpn: 'h2, http/1.1'
        } : null
      };
    } else if (selectedProtocol === 'dnssec') {
      details.packetData = {
        type: 'DNSSEC-signed DNS',
        transport: 'UDP/TCP',
        port: '53',
        encryption: 'None (use DoT/DoH for encryption)',
        size: currentStep.step >= 2 ? '~2048 bytes (with signatures)' : '29 bytes',
        dnsHeaders: {
          transactionId: '0x4a2b',
          flags: currentStep.step >= 4 ? 'QR=1, RD=1, AD=1' : 'QR=0, RD=1, DO=1',
          questions: 1,
          answers: currentStep.step >= 2 ? 1 : 0,
          authority: currentStep.step >= 2 ? 1 : 0,
          additional: currentStep.step >= 2 ? 2 : 1
        },
        query: {
          name: 'example.com',
          type: 'A',
          class: 'IN',
          dnssecOK: true
        },
        answer: currentStep.step >= 2 ? {
          name: 'example.com',
          type: 'A',
          class: 'IN',
          ttl: 86400,
          rdata: '93.184.216.34'
        } : null,
        dnssecRecords: currentStep.step >= 2 ? {
          rrsig: {
            type: 'RRSIG',
            algorithm: 'RSA/SHA-256 (8)',
            labels: 2,
            originalTTL: 86400,
            expiration: '20241201000000',
            inception: '20241101000000',
            keyTag: 12345,
            signerName: 'example.com',
            signature: '[256 bytes - cryptographic signature]'
          },
          dnskey: {
            type: 'DNSKEY',
            flags: 257,
            protocol: 3,
            algorithm: 8,
            publicKey: '[256 bytes - RSA public key]'
          }
        } : null,
        validationStatus: currentStep.step >= 3 ? 'Chain of trust verified âœ…' : 'Not yet validated'
      };
    }

    setPacketDetails(details);
    setShowPacketDetails(true);
  };

  const renderPacketDetailsModal = () => {
    if (!showPacketDetails || !packetDetails) return null;

    return (
      <div className="packet-details-overlay" onClick={() => setShowPacketDetails(false)}>
        <div className="packet-details-modal" onClick={(e) => e.stopPropagation()}>
          <div className="packet-modal-header">
            <h3>ðŸ“¦ Packet Details - {packetDetails.stepTitle}</h3>
            <button className="modal-close-btn" onClick={() => setShowPacketDetails(false)}>âœ•</button>
          </div>

          <div className="packet-modal-content">
            {/* Packet Overview */}
            <div className="packet-section">
              <h4>ðŸ” Packet Overview</h4>
              <div className="packet-info-grid">
                <div className="packet-info-item">
                  <span className="info-label">Protocol:</span>
                  <span className="info-value">{packetDetails.packetData.type}</span>
                </div>
                <div className="packet-info-item">
                  <span className="info-label">Transport:</span>
                  <span className="info-value">{packetDetails.packetData.transport}</span>
                </div>
                <div className="packet-info-item">
                  <span className="info-label">Port:</span>
                  <span className="info-value">{packetDetails.packetData.port}</span>
                </div>
                <div className="packet-info-item">
                  <span className="info-label">Encryption:</span>
                  <span className={`info-value ${packetDetails.encrypted ? 'encrypted' : 'plain'}`}>
                    {packetDetails.encrypted ? 'ðŸ”’ ' : 'ðŸ”“ '}{packetDetails.packetData.encryption}
                    {packetDetails.encrypted && <span className="encrypted-badge">ENCRYPTED</span>}
                  </span>
                </div>
                <div className="packet-info-item">
                  <span className="info-label">Packet Size:</span>
                  <span className="info-value">{packetDetails.packetData.size}</span>
                </div>
                <div className="packet-info-item">
                  <span className="info-label">State:</span>
                  <span className="info-value state-badge">{packetDetails.packetState || 'N/A'}</span>
                </div>
              </div>
            </div>

            {/* HTTP Headers (DoH only) */}
            {packetDetails.packetData.httpHeaders && (
              <div className="packet-section">
                <h4>ðŸŒ HTTP Headers <span className="encryption-indicator">ðŸ”’ HTTPS Encrypted</span></h4>
                <div className="packet-code-block encrypted-highlight">
                  <pre>
{`${packetDetails.packetData.httpHeaders.method} ${packetDetails.packetData.httpHeaders.path} HTTP/2
Host: ${packetDetails.packetData.httpHeaders.host}
Content-Type: ${packetDetails.packetData.httpHeaders.contentType}
Content-Length: ${packetDetails.packetData.httpHeaders.contentLength}
Accept: ${packetDetails.packetData.httpHeaders.accept}
User-Agent: ${packetDetails.packetData.httpHeaders.userAgent}`}
                  </pre>
                </div>
              </div>
            )}

            {/* TLS Information */}
            {packetDetails.packetData.tlsInfo && (
              <div className="packet-section tls-section">
                <h4>ðŸ” TLS Information <span className="encryption-indicator">ðŸ”’ Encrypted Layer</span></h4>
                <div className="packet-info-grid">
                  <div className="packet-info-item encrypted-highlight">
                    <span className="info-label">TLS Version:</span>
                    <span className="info-value">{packetDetails.packetData.tlsInfo.version}</span>
                  </div>
                  <div className="packet-info-item encrypted-highlight">
                    <span className="info-label">Cipher Suite:</span>
                    <span className="info-value">{packetDetails.packetData.tlsInfo.cipher}</span>
                  </div>
                  {packetDetails.packetData.tlsInfo.keyExchange && (
                    <div className="packet-info-item encrypted-highlight">
                      <span className="info-label">Key Exchange:</span>
                      <span className="info-value">{packetDetails.packetData.tlsInfo.keyExchange}</span>
                    </div>
                  )}
                  {packetDetails.packetData.tlsInfo.sni && (
                    <div className="packet-info-item encrypted-highlight">
                      <span className="info-label">SNI:</span>
                      <span className="info-value">{packetDetails.packetData.tlsInfo.sni}</span>
                    </div>
                  )}
                  {packetDetails.packetData.tlsInfo.recordType && (
                    <div className="packet-info-item encrypted-highlight">
                      <span className="info-label">Record Type:</span>
                      <span className="info-value">{packetDetails.packetData.tlsInfo.recordType}</span>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* DNS Data */}
            {packetDetails.packetData.dnsData && (
              <div className="packet-section">
                <h4>ðŸ“‹ DNS Data {packetDetails.encrypted && <span className="encryption-indicator">ðŸ”’ Protected by TLS</span>}</h4>
                <div className="packet-info-grid">
                  <div className="packet-info-item">
                    <span className="info-label">Transaction ID:</span>
                    <span className="info-value">{packetDetails.packetData.dnsData.transactionId}</span>
                  </div>
                  <div className={`packet-info-item ${packetDetails.encrypted ? 'encrypted-highlight' : ''}`}>
                    <span className="info-label">Query:</span>
                    <span className="info-value">
                      {packetDetails.packetData.dnsData.query}
                      {packetDetails.packetData.dnsData.query === '[ENCRYPTED]' && <span className="encrypted-badge">ENCRYPTED</span>}
                    </span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Query Type:</span>
                    <span className="info-value">{packetDetails.packetData.dnsData.queryType}</span>
                  </div>
                  {packetDetails.packetData.dnsData.format && (
                    <div className="packet-info-item">
                      <span className="info-label">Format:</span>
                      <span className="info-value">{packetDetails.packetData.dnsData.format}</span>
                    </div>
                  )}
                </div>
              </div>
            )}

            {/* DNS Headers (DNSSEC) */}
            {packetDetails.packetData.dnsHeaders && (
              <div className="packet-section">
                <h4>ðŸ“‹ DNS Headers</h4>
                <div className="packet-info-grid">
                  <div className="packet-info-item">
                    <span className="info-label">Transaction ID:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.transactionId}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Flags:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.flags}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Questions:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.questions}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Answers:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.answers}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Authority:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.authority}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Additional:</span>
                    <span className="info-value">{packetDetails.packetData.dnsHeaders.additional}</span>
                  </div>
                </div>
              </div>
            )}

            {/* DNSSEC Records */}
            {packetDetails.packetData.dnssecRecords && (
              <div className="packet-section">
                <h4>âœ… DNSSEC Signature Records</h4>
                
                <div className="dnssec-record">
                  <h5>RRSIG (Resource Record Signature)</h5>
                  <div className="packet-code-block">
                    <pre>
{`Type: ${packetDetails.packetData.dnssecRecords.rrsig.type}
Algorithm: ${packetDetails.packetData.dnssecRecords.rrsig.algorithm}
Labels: ${packetDetails.packetData.dnssecRecords.rrsig.labels}
Original TTL: ${packetDetails.packetData.dnssecRecords.rrsig.originalTTL}
Signature Expiration: ${packetDetails.packetData.dnssecRecords.rrsig.expiration}
Signature Inception: ${packetDetails.packetData.dnssecRecords.rrsig.inception}
Key Tag: ${packetDetails.packetData.dnssecRecords.rrsig.keyTag}
Signer Name: ${packetDetails.packetData.dnssecRecords.rrsig.signerName}
Signature: ${packetDetails.packetData.dnssecRecords.rrsig.signature}`}
                    </pre>
                  </div>
                </div>

                <div className="dnssec-record">
                  <h5>DNSKEY (Public Key)</h5>
                  <div className="packet-code-block">
                    <pre>
{`Type: ${packetDetails.packetData.dnssecRecords.dnskey.type}
Flags: ${packetDetails.packetData.dnssecRecords.dnskey.flags} (KSK - Key Signing Key)
Protocol: ${packetDetails.packetData.dnssecRecords.dnskey.protocol}
Algorithm: ${packetDetails.packetData.dnssecRecords.dnskey.algorithm}
Public Key: ${packetDetails.packetData.dnssecRecords.dnskey.publicKey}`}
                    </pre>
                  </div>
                </div>

                <div className="validation-status">
                  <strong>Validation Status:</strong> {packetDetails.packetData.validationStatus}
                </div>
              </div>
            )}

            {/* Regular Headers (DoT) */}
            {packetDetails.packetData.headers && !packetDetails.packetData.dnsHeaders && (
              <div className="packet-section">
                <h4>ðŸ“‹ DNS Headers {packetDetails.encrypted && <span className="encryption-indicator">ðŸ”’ Protected by TLS</span>}</h4>
                <div className="packet-info-grid">
                  <div className="packet-info-item">
                    <span className="info-label">Transaction ID:</span>
                    <span className="info-value">{packetDetails.packetData.headers.transactionId}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Flags:</span>
                    <span className="info-value">{packetDetails.packetData.headers.flags}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Questions:</span>
                    <span className="info-value">{packetDetails.packetData.headers.questions}</span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Answers:</span>
                    <span className="info-value">{packetDetails.packetData.headers.answers}</span>
                  </div>
                </div>
                <div className="packet-info-grid" style={{ marginTop: '12px' }}>
                  <div className={`packet-info-item ${packetDetails.encrypted ? 'encrypted-highlight' : ''}`}>
                    <span className="info-label">Query Name:</span>
                    <span className="info-value">
                      {packetDetails.packetData.query}
                      {packetDetails.packetData.query === '[ENCRYPTED]' && <span className="encrypted-badge">ENCRYPTED</span>}
                    </span>
                  </div>
                  <div className="packet-info-item">
                    <span className="info-label">Query Type:</span>
                    <span className="info-value">{packetDetails.packetData.queryType}</span>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const nextStep = () => {
    const steps = getProtocolSteps(selectedProtocol);
    if (simulationStep < steps.length - 1) {
      setSimulationStep(simulationStep + 1);
    }
  };

  const prevStep = () => {
    if (simulationStep > 0) {
      setSimulationStep(simulationStep - 1);
    }
  };

  const resetSimulation = () => {
    setSimulationStep(0);
    setSelectedNode(null);
  };

  const startSimulation = () => {
    setShowBrief(false);
    setSimulationStep(0);
    setSelectedNode(null);
  };

  const renderProtocolBrief = () => {
    const protocol = protocols.find(p => p.id === selectedProtocol);
    if (!protocol) return null;

    return (
      <div className="security-brief-overlay">
        <div className="security-brief-panel">
          <div className="brief-header" style={{ background: `linear-gradient(135deg, ${protocol.color} 0%, ${protocol.color}dd 100%)` }}>
            <h2>
              <span className="brief-icon">{protocol.icon}</span>
              {protocol.name}
            </h2>
            <p className="brief-subtitle">{protocol.standard}</p>
          </div>

          <div className="brief-content">
            {/* Overview */}
            <div className="brief-section">
              <h3>ðŸ” Protocol Overview</h3>
              <p className="overview-text">{protocol.description}</p>
              <div className="protocol-specs">
                <div className="spec-item">
                  <strong>Port:</strong> {protocol.port}
                </div>
                <div className="spec-item">
                  <strong>Standard:</strong> {protocol.standard}
                </div>
                <div className="spec-item">
                  <strong>Adoption:</strong> {protocol.adoption}
                </div>
              </div>
            </div>

            {/* Benefits */}
            <div className="brief-section">
              <h3>âœ¨ Key Benefits</h3>
              <p className="benefits-text">{protocol.benefits}</p>
            </div>

            {/* How It Works */}
            <div className="brief-section">
              <h3>âš™ï¸ How It Works</h3>
              <div className="flow-summary">
                {selectedProtocol === 'dot' && (
                  <ol className="flow-list">
                    <li>Client prepares DNS query (unencrypted)</li>
                    <li>TLS handshake on port 853 establishes encryption</li>
                    <li>DNS query encrypted and transmitted</li>
                    <li>Resolver decrypts and performs lookup</li>
                    <li>Response encrypted and sent back</li>
                    <li>Client decrypts and uses the answer</li>
                  </ol>
                )}
                {selectedProtocol === 'doh' && (
                  <ol className="flow-list">
                    <li>Client creates DNS query (binary format)</li>
                    <li>HTTPS connection established (port 443)</li>
                    <li>DNS query wrapped in HTTP POST/GET request</li>
                    <li>Encrypted transmission (looks like web traffic)</li>
                    <li>Resolver extracts and processes DNS query</li>
                    <li>Response wrapped in HTTP and encrypted</li>
                    <li>Client decrypts and extracts DNS answer</li>
                  </ol>
                )}
                {selectedProtocol === 'dnssec' && (
                  <ol className="flow-list">
                    <li>Client sends DNS query with DNSSEC flag</li>
                    <li>Server responds with answer + digital signatures</li>
                    <li>Resolver validates signature chain (root â†’ TLD â†’ domain)</li>
                    <li>Client receives validated answer or error</li>
                  </ol>
                )}
              </div>
            </div>

            {/* Key Concepts */}
            <div className="brief-section">
              <h3>ðŸ’¡ Key Concepts</h3>
              <div className="concepts-grid">
                {selectedProtocol === 'dot' && (
                  <>
                    <div className="concept-card">
                      <strong>Dedicated Port</strong>
                      <p>Port 853 exclusively for DNS over TLS</p>
                    </div>
                    <div className="concept-card">
                      <strong>TLS 1.3</strong>
                      <p>Modern encryption with forward secrecy</p>
                    </div>
                    <div className="concept-card">
                      <strong>Certificate Validation</strong>
                      <p>Verifies resolver identity via X.509</p>
                    </div>
                    <div className="concept-card">
                      <strong>Privacy Protection</strong>
                      <p>ISP cannot see DNS queries</p>
                    </div>
                  </>
                )}
                {selectedProtocol === 'doh' && (
                  <>
                    <div className="concept-card">
                      <strong>HTTPS Port 443</strong>
                      <p>Indistinguishable from web traffic</p>
                    </div>
                    <div className="concept-card">
                      <strong>HTTP Encapsulation</strong>
                      <p>DNS wrapped in HTTP request/response</p>
                    </div>
                    <div className="concept-card">
                      <strong>Censorship Resistant</strong>
                      <p>Bypasses DNS-specific filtering</p>
                    </div>
                    <div className="concept-card">
                      <strong>Browser Integration</strong>
                      <p>Native support in modern browsers</p>
                    </div>
                  </>
                )}
                {selectedProtocol === 'dnssec' && (
                  <>
                    <div className="concept-card">
                      <strong>Digital Signatures</strong>
                      <p>Cryptographic proof of authenticity</p>
                    </div>
                    <div className="concept-card">
                      <strong>Chain of Trust</strong>
                      <p>Root â†’ TLD â†’ Domain validation</p>
                    </div>
                    <div className="concept-card">
                      <strong>RRSIG Records</strong>
                      <p>Signatures attached to DNS answers</p>
                    </div>
                    <div className="concept-card">
                      <strong>Integrity Check</strong>
                      <p>Detects tampering and poisoning</p>
                    </div>
                  </>
                )}
              </div>
            </div>

            {/* Security Note */}
            <div className="brief-section security-note">
              <h3>ðŸ›¡ï¸ Security Impact</h3>
              <div className="security-box">
                {selectedProtocol === 'dot' && (
                  <>
                    <p><strong>Protects Against:</strong></p>
                    <ul>
                      <li>âœ… DNS eavesdropping (ISP monitoring)</li>
                      <li>âœ… Man-in-the-middle attacks</li>
                      <li>âœ… DNS hijacking on untrusted networks</li>
                      <li>âœ… Query logging by network operators</li>
                    </ul>
                    <p className="note-text"><strong>Note:</strong> DoT uses dedicated port 853, which makes it easy to identify and potentially block. Consider DoH for maximum compatibility.</p>
                  </>
                )}
                {selectedProtocol === 'doh' && (
                  <>
                    <p><strong>Protects Against:</strong></p>
                    <ul>
                      <li>âœ… All DoT protections PLUS:</li>
                      <li>âœ… DNS-based censorship (looks like HTTPS)</li>
                      <li>âœ… Network-level DNS blocking</li>
                      <li>âœ… Corporate firewall restrictions</li>
                      <li>âœ… Traffic analysis (hides DNS patterns)</li>
                    </ul>
                    <p className="note-text"><strong>Note:</strong> DoH provides maximum privacy but requires trust in DoH provider. Combine with DNSSEC for authenticity.</p>
                  </>
                )}
                {selectedProtocol === 'dnssec' && (
                  <>
                    <p><strong>Protects Against:</strong></p>
                    <ul>
                      <li>âœ… DNS cache poisoning (Kaminsky attack)</li>
                      <li>âœ… Forged DNS responses</li>
                      <li>âœ… Man-in-the-middle DNS manipulation</li>
                      <li>âœ… DNS spoofing attacks</li>
                    </ul>
                    <p className="warning-text"><strong>Important:</strong> DNSSEC validates authenticity but does NOT encrypt queries. For privacy, combine DNSSEC with DoT or DoH!</p>
                  </>
                )}
              </div>
            </div>

            {/* Comparison with other protocols */}
            <div className="brief-section comparison-section">
              <h3>âš–ï¸ Quick Comparison</h3>
              <div className="comparison-table">
                <div className="comparison-row header-row">
                  <div className="comparison-cell">Feature</div>
                  <div className="comparison-cell">DoT</div>
                  <div className="comparison-cell">DoH</div>
                  <div className="comparison-cell">DNSSEC</div>
                </div>
                <div className="comparison-row">
                  <div className="comparison-cell"><strong>Privacy</strong></div>
                  <div className="comparison-cell">{selectedProtocol === 'dot' ? 'âœ… High' : 'âœ…'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'doh' ? 'âœ… Maximum' : 'âœ…'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'dnssec' ? 'âŒ None' : 'âŒ'}</div>
                </div>
                <div className="comparison-row">
                  <div className="comparison-cell"><strong>Authenticity</strong></div>
                  <div className="comparison-cell">âš ï¸ Server</div>
                  <div className="comparison-cell">âš ï¸ Server</div>
                  <div className="comparison-cell">{selectedProtocol === 'dnssec' ? 'âœ… Maximum' : 'âœ…'}</div>
                </div>
                <div className="comparison-row">
                  <div className="comparison-cell"><strong>Port</strong></div>
                  <div className="comparison-cell">{selectedProtocol === 'dot' ? '853 ðŸ“' : '853'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'doh' ? '443 ðŸ“' : '443'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'dnssec' ? '53 ðŸ“' : '53'}</div>
                </div>
                <div className="comparison-row">
                  <div className="comparison-cell"><strong>Blockable</strong></div>
                  <div className="comparison-cell">{selectedProtocol === 'dot' ? 'âš ï¸ Easy' : 'âš ï¸'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'doh' ? 'âœ… Hard' : 'âœ…'}</div>
                  <div className="comparison-cell">âš ï¸ Easy</div>
                </div>
                <div className="comparison-row">
                  <div className="comparison-cell"><strong>Best For</strong></div>
                  <div className="comparison-cell">{selectedProtocol === 'dot' ? 'ðŸ“Œ Privacy' : 'Privacy'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'doh' ? 'ðŸ“Œ Max Privacy' : 'Max Privacy'}</div>
                  <div className="comparison-cell">{selectedProtocol === 'dnssec' ? 'ðŸ“Œ Authenticity' : 'Authenticity'}</div>
                </div>
              </div>
              <p className="comparison-note">
                ðŸ’¡ <strong>Recommendation:</strong> Use DoH or DoT for privacy, and enable DNSSEC for authenticity. Together they provide complete DNS security!
              </p>
            </div>
          </div>

          {/* Action Buttons */}
          <div className="brief-actions">
            <button
              className="back-to-list-btn"
              onClick={() => {
                setSelectedProtocol(null);
                setShowBrief(false);
              }}
            >
              â† Back to Protocols
            </button>
            <button
              className="start-simulation-btn"
              style={{ background: `linear-gradient(135deg, ${protocol.color} 0%, ${protocol.color}cc 100%)` }}
              onClick={startSimulation}
            >
              â–¶ Start Simulation
            </button>
          </div>
        </div>
      </div>
    );
  };

  return (
    <div className="security-protocols-overlay">
      <div className="security-protocols-panel">
        {/* Header */}
        <div className="panel-header">
          <div className="header-left">
            <h2>ðŸ” DNS Security Protocols</h2>
            <p>Learn how modern security protects your DNS queries</p>
          </div>
          <button className="close-btn" onClick={onClose}>âœ•</button>
        </div>

        {/* Protocol Selection Grid */}
        {!selectedProtocol && (
          <div className="protocols-grid">
            {protocols.map(protocol => (
              <div
                key={protocol.id}
                className="protocol-card"
                style={{ borderColor: protocol.color }}
                onClick={() => {
                  setSelectedProtocol(protocol.id);
                  setShowBrief(true);
                }}
              >
                <div className="protocol-icon" style={{ background: protocol.color }}>
                  {protocol.icon}
                </div>
                <h3>{protocol.name}</h3>
                <div className="protocol-meta">
                  <span className="port-badge" style={{ background: `${protocol.color}22`, color: protocol.color }}>
                    Port {protocol.port}
                  </span>
                  <span className="standard-badge">{protocol.standard}</span>
                </div>
                <p className="protocol-description">{protocol.description}</p>
                <div className="protocol-benefits">
                  <strong>Benefits:</strong>
                  <p>{protocol.benefits}</p>
                </div>
                <button
                  className="simulate-btn"
                  style={{ background: protocol.color }}
                  onClick={(e) => {
                    e.stopPropagation();
                    setSelectedProtocol(protocol.id);
                    setShowBrief(true);
                  }}
                >
                  â–¶ Learn More
                </button>
              </div>
            ))}
          </div>
        )}

        {/* Protocol Brief */}
        {selectedProtocol && showBrief && renderProtocolBrief()}

        {/* Simulation View */}
        {selectedProtocol && !showBrief && (
          <div className="simulation-view">
            <div className="simulation-header">
              <button className="back-btn" onClick={() => {
                setSelectedProtocol(null);
                setSimulationStep(0);
                setSelectedNode(null);
              }}>
                â† Back
              </button>
              <h3>{protocols.find(p => p.id === selectedProtocol)?.name}</h3>
            </div>

            <div className="simulation-content">
              {/* Visualization */}
              <div className="visualization-container">
                <svg ref={svgRef} className="security-svg"></svg>
              </div>

              {/* Step Info */}
              <div className="step-info-panel">
                {getProtocolSteps(selectedProtocol)[simulationStep] && (
                  <>
                    <div className="step-header">
                      <h4>
                        {getProtocolSteps(selectedProtocol)[simulationStep].title}
                      </h4>
                      <div className="step-badge" style={{ background: protocols.find(p => p.id === selectedProtocol)?.color }}>
                        Step {simulationStep + 1}/{getProtocolSteps(selectedProtocol).length}
                      </div>
                    </div>

                    <div className="step-description">
                      <p>{getProtocolSteps(selectedProtocol)[simulationStep].description}</p>
                    </div>

                    {getProtocolSteps(selectedProtocol)[simulationStep].technicalDetails && (
                      <div className="technical-details">
                        <h5>ðŸ”§ Technical Details</h5>
                        <pre>{getProtocolSteps(selectedProtocol)[simulationStep].technicalDetails}</pre>
                      </div>
                    )}

                    {selectedNode && selectedNode.step === simulationStep && (
                      <div className="node-details">
                        <h5>ðŸ“ Selected: {selectedNode.nodeId}</h5>
                        <p>{selectedNode.data.description}</p>
                      </div>
                    )}
                  </>
                )}
              </div>
            </div>

            {/* Controls */}
            <div className="simulation-controls">
              <button onClick={prevStep} disabled={simulationStep === 0} className="nav-btn">
                â® Previous
              </button>
              <span className="step-counter">
                Step {simulationStep + 1} / {getProtocolSteps(selectedProtocol).length}
              </span>
              <button onClick={nextStep} disabled={simulationStep >= getProtocolSteps(selectedProtocol).length - 1} className="nav-btn">
                Next â­
              </button>
              <button onClick={resetSimulation} className="reset-btn">
                ðŸ”„ Reset
              </button>
            </div>

            {/* Progress Bar */}
            <div className="progress-container">
              <div
                className="progress-bar"
                style={{
                  width: `${((simulationStep + 1) / getProtocolSteps(selectedProtocol).length) * 100}%`,
                  background: protocols.find(p => p.id === selectedProtocol)?.color
                }}
              ></div>
            </div>
          </div>
        )}

        {/* Packet Details Modal */}
        {showPacketDetails && renderPacketDetailsModal()}
      </div>
    </div>
  );
}

export default SecurityProtocolsPanel;
